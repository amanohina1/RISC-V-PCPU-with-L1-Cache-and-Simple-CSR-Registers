# 设计与调试日志：从理论到实践的挑战

CPU设计不仅是搭建正确的数据通路，更是在面对复杂时序和异步事件时，确保系统稳健性的艺术。本项目在开发过程中遇到并解决了一系列经典的设计挑战，以下记录了其中三个最具代表性的调试经历。

这三个故事分别展示了本项目在**控制流与异常处理（逻辑层面）**、**内存子系统与时序（物理层面）**、以及**流水线核心时序（时钟沿层面）**这三大核心领域所达到的设计深度。

---

### 故事一：驯服“幽灵”信号——流水线冷启动与异常处理的优雅结合

*   **现象 (Symptom):** 在初步实现异常处理机制后，CPU在复位（上电）后的最初几个周期，会无故触发一次“非法指令”异常。`Control`控制单元的译码逻辑似乎受到了来自数据通路中残留“垃圾”信号的干扰。
*   **困境 (Dilemma):** 直观地拦截这些早期无效信号，会同时阻塞正常的异常处理通路，导致系统无法响应真正的异常（如`ecall`）。问题陷入僵局：要么容忍启动时的伪异常，要么破坏正常的异常机制。
*   **洞见与解决方案 (Insight & Solution):** 意识到问题的根源在于混淆了“未初始化”和“真·异常”两种状态后，我设计了一套双重保障机制：
    1.  **流水线寄存器初始化逻辑:** 为所有流水线寄存器设计了带复位端的更新逻辑。在系统复位时，强制将流水线刷新为确定的“无效指令”（`nop`）状态，从而消除启动时的随机信号干扰。
    2.  **专用异常识别位:** 在`ID/EX`流水线寄存器中，增设了一个专门的`is_exception`信号。所有类型的异常在译码阶段被检测到后，都会置位这个标志。后续流水线阶段判断是否进入异常处理模式的**唯一依据**就是检查该信号，使其成为一条清晰、高优先级的异常信息通道。

*   **收获 (Lesson Learned):** **优秀的设计，往往在于对不同的系统状态做出清晰的定义与隔离。** 通过为启动和异常这两种特殊流程设计专门的硬件支持，我们以最小的代价解决了看似复杂的逻辑冲突。

---

### 故事二：追捕“瞬时”错误——L1缓存写回与流水线停顿的致命竞态

*   **现象 (Symptom):** 在运行对数组进行连续写操作的测试时，仿真结果偶尔会出现数据校验错误，且难以复现。直接检查缓存，其内容正确，但最终写回内存或被后续指令使用的却是错误数据。
*   **排查 (Investigation):** 经过数个日夜的波形图追踪，最终定位到错误仅在一种特定情况下发生：当流水线因**加载-使用冒险而停顿（Load-Use Stall）**时，恰好有一个“脏”的缓存块需要被**替换并写回主存**。
*   **根本原因 (Root Cause):** 这是一个经典的**时序竞争（Race Condition）**。当`Hazard`单元让流水线停顿时，它会冻结WB阶段的写回。然而，我的`Cache`控制器的写回逻辑没有与`Hazard`单元同步，它错误地认为WB阶段的总线是空闲的，并将自己准备写回的脏数据强行驱动到总线上，与ALU试图保持的结果发生了**总线冲突（Bus Contention）**，最终导致一个不确定的`x`值被写入寄存器堆。
*   **解决方案 (Solution):** 解决方案的核心是建立明确的**“总线仲裁”**机制，并确立`Hazard`单元的最高优先级。我重构了WB阶段的逻辑，当`pipeline_stall`信号有效时，它会**强制**冻结所有对寄存器堆的写操作，并通知`Cache`控制器将其写回请求**推迟一个周期**。
*   **收获 (Lesson Learned):** **在复杂的流水线设计中，一个集中式的、拥有最高优先级的冒险/停顿控制单元是至关重要的。** 任何模块与流水线的交互，都必须尊重其控制信号，否则看似无关的两个事件就可能在某个时钟沿的瞬间，引发致命的硬件冲突。

---

### 故事三：穿越时空的救援——解决寄存器堆上的“写后读”竞态

*   **现象 (Symptom):** 在执行极其紧凑的、背靠背的依赖指令序列时（例如 `addi x6, x5, 1` 紧跟在 `addi x5, x0, 10` 之后），计算结果出错。
*   **排查 (Investigation):** 问题在于，当第二条指令在**译码（ID）阶段**需要读取`x5`时，第一条指令**几乎在同一时刻**正处于**写回（WB）阶段**。由于寄存器堆的读是组合逻辑（立即发生），而写是同步逻辑（在时钟上升沿才生效），ID阶段的读操作总比WB阶段的写操作“抢跑”了纳秒级的时间，导致读到的是旧值。标准的WB->EX前递对此无能为力，因为错误在ID阶段已经发生。
*   **解决方案 (Solution):** 既然问题出在“读”与“写”在同一个时钟上升沿的竞态，我采用了一个非常规但有效的工程技巧：**将寄存器堆的写操作改为在时钟的负边沿（negedge clk）触发。** 这使得新数据在周期的前半段就已经被写入并稳定下来。当下一个周期的上升沿到来时，ID阶段的读操作便能确保读到最新值。综合后的时序分析表明，这一改动并未造成时序违例，证明了其在当前设计中的可行性。
*   **收获 (Lesson Learned):** **流水线的前递逻辑并非万能。** 对于寄存器堆这种核心组件，必须深入到其物理实现的同步/异步时序层面，理解并驾驭时钟沿级别的行为，才能根除一些隐藏极深的竞态冒险。

---

### 我还能如何努力？(Your Growth Roadmap)

你已经打下了极其坚实的基础，现在需要的是系统性地扩展你的知识边界和工程视野。这是一条从“优秀的CPU设计者”迈向“顶尖的系统架构师/IC工程师”的路径。

#### 短期目标 (本学期 ~ 下一个暑假)

1.  **完成SoC集成与FPGA原型验证 (动手能力拓展):**
    *   **任务:**
        1.  **实现AXI4-Lite桥接模块:** 将你的CPU核心的内存接口，连接到一个标准的AXI4-Lite总线上。这是将你的核心产品化的第一步。
        2.  **集成基本外设:** 在总线上挂载一个UART（用于`printf`调试）、一个GPIO（用于点亮FPGA上的LED）和一个Timer（为中断做准备）。
        3.  **上板验证:** 编写一个简单的、能通过UART打印“Hello World!”的裸机程序，并成功地在FPGA开发板上运行它。
    *   **为什么:** 这会强迫你跳出CPU核心的“舒适区”，开始从系统角度思考问题：地址映射、总线协议、外设驱动... **这是你从设计一个“计算核心”到设计一个“计算机系统”的决定性一步。**

2.  **搭建自动化协同仿真环境 (验证能力深化):**
    *   **任务:** 学习并使用Verilator，搭建一个你的CPU模型与RISC-V黄金参照模型Spike进行**协同仿真**的测试平台。
    *   **为什么:** 这会让你体验到工业级的验证流程。你的CPU每执行一条指令，都要和Spike的行为进行比对。这能发现你手写Testbench永远无法覆盖的边界情况，是保证CPU`100%`指令集兼容性的唯一途径。**这项技能在简历上的价值，甚至不亚于你的CPU设计本身。**

#### 中期目标 (未来1-2年)

3.  **挑战高级流水线特性 (理论深度加强):**
    *   **任务:**
        1.  **实现动态分支预测器:** 根据你自己的性能分析，这是你当前CPU最大的性能瓶颈。实现一个带BHT（分支历史表）的2位饱和计数器预测器，看看你的CPI能从1.16降低到多少。
        2.  **实现L1指令缓存 (I-Cache):** 让你的哈佛结构变得完整，并处理指令/数据缓存的一致性问题（虽然单核上主要是通过软件刷新或硬件自动刷新）。
    *   **为什么:** 这是计算机体系结构课程的进阶核心内容。亲手实现它们，会让你对现代CPU如何榨干性能有更深刻的理解。

4.  **学习数字IC后端基础知识 (工程视野拓宽):**
    *   **任务:** 利用学校提供的EDA工具（如Synopsys Design Compiler, Cadence Innovus），尝试对自己CPU的一个小模块（如ALU）进行一次简单的**逻辑综合**与**布局布线（Place & Route）**流程。
    *   **为什么:** 这会让你第一次亲眼看到你的代码是如何变成真实的晶体管版图的。你会直观地理解什么是“关键路径”、“时序收敛”、“功耗”，这些概念会反过来让你在写前端RTL代码时，思考得更深入。**这是从“逻辑设计”迈向“物理设计”的一步。**

#### 长期目标 (本科毕业及以后)

5.  **深入一个垂直领域:**
    *   **AI加速器？** 学习张量计算和神经网络，尝试设计一个与你的RISC-V核协同工作的TPU。
    *   **高可靠性系统？** 学习冗余设计、ECC内存，为你的CPU添加容错功能。
    *   **操作系统内核？** 深入学习RISC-V特权级架构，实现支持分页的MMU，并在你的FPGA系统上移植一个简单的操作系统内核（如xv6）。
    *   **乱序执行？** 当你完成了以上所有，你已经具备了挑战乱序执行核心的所有前置知识。
